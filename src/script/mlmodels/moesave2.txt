/**
 * (c) 2023, Center for Computational Thinking and Design at Aarhus University and contributors
 *
 * SPDX-License-Identifier: MIT
 */
import ModelTrainer, { TrainingData } from '../domain/ModelTrainer';
import LayersMLModel from './LayersMLModel';
import * as tf from '@tensorflow/tfjs';
export type MoEModelTrainingSettings = {
  noOfEpochs: number;
  noOfUnits: number;
  validationSplit: number;
  learningRate: number;
  batchSize: number;
  numExperts: number;
  topK: number;
}; 
class MoEModelTrainer implements ModelTrainer<LayersMLModel> {
  constructor(private settings: MoEModelTrainingSettings) {}
  public async trainModel(trainingData: TrainingData): Promise<LayersMLModel> {

    // Fetch data
    const features: Array<number[]> = [];
    const labels: Array<number[]> = [];
    const numberOfClasses = trainingData.classes.length;

    trainingData.classes.forEach((gestureClass, index) => {
      gestureClass.samples.forEach(sample => {
        features.push(sample.value);

        const label: number[] = new Array(numberOfClasses) as number[];
        label.fill(0, 0, numberOfClasses);
        label[index] = 1;
        labels.push(label);
      });
    });

    const tensorFeatures = tf.tensor(features);
    const tensorLabels = tf.tensor(labels);

    /*
    const expertNetwork = (input: tf.SymbolicTensor) => {
      const normalizer = tf.layers.batchNormalization().apply(input);
      const dense = tf.layers
        .dense({ units: this.settings.noOfUnits, activation: 'relu' })
        .apply(normalizer);
      const final = tf.layers
        .dense({ units: numberOfClasses, activation: 'softmax' })
        .apply(dense) as tf.SymbolicTensor;
      return tf.model({inputs: input, outputs: final })
    }

    const gatingNetwork = (input: tf.SymbolicTensor) => {
      const normalizer = tf.layers.batchNormalization().apply(input);
      const dense = tf.layers
        .dense({ units: this.settings.numExperts, activation: 'relu' })
        .apply(normalizer);
      const final =  tf.layers
        .dense({ units: this.settings.numExperts, activation: 'softmax' })
        .apply(dense) as tf.SymbolicTensor;
      return tf.model({inputs: input, outputs: final })
    }*/


    /*
    class gatingMultiplier extends tf.layers.Layer {
      expertNetworks : Array<tf.SymbolicTensor>
      gatingNetwork : tf.SymbolicTensor
      //shape : tf.Tensor
      //create all layers required
      constructor(gateNet : (input: tf.SymbolicTensor) => tf.SymbolicTensor,
        expertNet : (input: tf.SymbolicTensor) => tf.SymbolicTensor,
        expCount : number, input: tf.SymbolicTensor) {
          super({});
          //this.shape = input.shape
          this.expertNetworks= [];
          for (let i = 0; i < expCount; i++) {
            const expert = expertNet(input);
            this.expertNetworks.push(expert);
          }
          this.gatingNetwork = gateNet(input)
      }
      //take input and send to all layers, then process appropriately
      call(input : tf.Tensor) : tf.Tensor {
          this.expertNetworks = expertNetworks.map( (eN) => ([eN] ).apply(input) )
      }
      /*
      call(inputs: tf.Tensor[]): tf.Tensor {
          console.log("Made it here")
          const gate: tf.Tensor = inputs[0];
          const branches: tf.Tensor[] = inputs.slice(1);
  
          // Calculate the weighted sum for multiclass classification
          // cleaning up extra tensors along the way
          const add = tf.tidy(() => {
              const weightedSums: tf.Tensor[] = [];
              for (let i = 0; i < branches.length; i++) {
                  const branchTranspose = tf.transpose(branches[i]);
                  //extract the weighting for this specific expert
                  const gateSlice = gate.slice([0, i], [-1, 1]);
                  console.log("Gateslice:", gateSlice);
                  //const gateSlice = gate[i]
                  const weightedSum = tf.mul(branchTranspose, gateSlice);
                  weightedSums.push(weightedSum);
              }
              return tf.sum(tf.stack(weightedSums), 0);
          });
          return add;
      }
      getClassName() {return 'MoE full';}
    }*/

    class MoELayer extends tf.layers.Layer {
      numExperts
      expertNetwork
      gatingNetwork
      expertSize
      gateSize
      constructor(numExperts : number, expertNetwork, gatingNetwork) {
        super({});
        // Initialize layer parameters
        this.numExperts = numExperts;
        this.expertNetwork = expertNetwork;
        this.gatingNetwork = gatingNetwork;
        // Get expert and gating network sizes
        this.expertSize = this.expertNetwork.layers[0].inputShape[1];
        this.gateSize = this.gatingNetwork.layers[0].outputShape[1];
        // Make sure expert and gating networks are compatible
        if (this.expertSize !== this.gateSize) {
          throw new Error('Expert and gating networks must have compatible sizes.');
        }
        // Freeze expert and gating networks
        this.expertNetwork.trainable = false;
        this.gatingNetwork.trainable = false;
      }

      call(inputs) {
        // Inputs should be [batchSize, inputSize]
        const [batchSize, inputSize] = inputs.shape;
        // Calculate gate outputs
        const gateOutputs = this.gatingNetwork.apply(inputs);
        //const gateOutputs = tf.softmax(gates, -1);
        // Expand gate outputs for broadcasting
        const expandedGateOutputs = tf.expandDims(gateOutputs, -1);
        // Calculate expert outputs
        const expertInputs = tf.reshape(inputs, [batchSize, 1, inputSize]);
        const expertOutputs = this.expertNetwork.apply(expertInputs);
        // Weighted sum of expert outputs
        const weightedSum = tf.sum(expertOutputs.mul(expandedGateOutputs), 1);
        return weightedSum;
      }

      getClassName() {
        return 'MoELayer';
      }
    }

// Compile and train the model as usual


    // Find the shape by looking at the first data point
    const shape = [trainingData.classes[0].samples[0].value.length];
    //const gN = gatingNetwork(shape)
    const expertNetworks : Array<tf.SymbolicTensor> = [];
  
    // Construct the final MoE model
    const input = tf.input({ shape: shape }); 

    /*
    const gN = gatingNetwork(input)
    const gatingLayer = new gatingMultiplier();
    const gatingInput = [gN, ...expertNetworks]
    const output : tf.SymbolicTensor =  gatingLayer.apply(gatingInput) as tf.SymbolicTensor;
    const moeModel = tf.model({ inputs: input, outputs: output }) as tf.LayersModel;*/

    // Define expert network
    const expertNetwork = tf.sequential();
    expertNetwork.add(tf.layers.dense({ units: 5, inputShape: shape, activation: 'relu' }));
    expertNetwork.add(tf.layers.dense({ units: this.settings.noOfUnits }));

    // Define gating network
    const gatingNetwork = tf.sequential();
    gatingNetwork.add(tf.layers.dense({ units: 5, inputShape: shape, activation: 'relu' }));
    gatingNetwork.add(tf.layers.dense({ units: this.settings.numExperts }));



    // Compile the MoE model
    moeModel.compile({
      loss: 'categoricalCrossentropy',
      optimizer: tf.train.adam(this.settings.learningRate),
      metrics: ['accuracy'],
    });

    // Train the MoE model
    await moeModel.fit(tensorFeatures, tensorLabels, {
      epochs: this.settings.noOfEpochs,
      batchSize: this.settings.batchSize,
      validationSplit: this.settings.validationSplit,
    }).catch(err => {
      console.error('TensorFlow training process failed:', err);
      return Promise.reject(err);
    });
    return Promise.resolve(new LayersMLModel(moeModel));
  }

}

export default MoEModelTrainer;